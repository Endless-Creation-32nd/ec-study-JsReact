### 01. 리액트는 어쩌다 만들어졌을까?

HTML 로 구성한 UI 를 제어할 때, DOM 을 변형시키기 위해선 브라우저의 Seletor API 를 사용해 특정 DOM 을 선택, 특정 이벤트가 발생하면 변화를 주도록 설정해야함.

~~~html
<h2 id="number">0</h2>
<div>
  <button id="increase">+1</button>
  <button id="decrease">-1</button>
</div>
~~~

이렇게 **'+1'과 '-1'** 버튼이 구성되어 있고, **id** 를 사용해 각 **DOM** 을 선택한 뒤, 원하는 이벤트가 발생하면 DOM 의 특정 속성을 바꾸어 주어야 한다.

~~~javascript
const number = document.getElementById('number');
const increase = document.getElementById('increase');
const decrease = document.getElementById('decrease');

increase.onclick = () => {
  const current = parseInt(number.innerText, 10);
  number.innerText = current + 1;
};

decrease.onclick = () => {
  const current = parseInt(number.innerText, 10);
  number.innerText = current - 1;
};
~~~

위 코드에는 'id 가 number 인 DOM 을 선택해서 innerText 속성을 1씩 더해줘라' 라는 규칙이 있다. 
사용자와의 상호작용이 별로 없는 웹페이지라면 상관 없겠지만 다양한 상호작용이 발생하면 이에 따른 규칙이 다양해져, 관리하기가 힘들어 질 것임.

이를 해결하기 위해 Ember, Bacnbone, AngularJS 등의 프레임워크 등장, 작동 방식은 각각 다르지만 JS 의 특정 값이 바뀌면 특정 DOM 의 속성이 바뀌도록 연결해줘 업데이트 작업을 간소화해주는 방식임.

반면, 리액트는 DOM 을 어떻게 업데이트할 지에 대한 것이 아닌, 기존 DOM 을 없애버리고 새로운 DOM 을 만들어서 보여주면 어떨까 라는 아이디어에서 착안함. 

이런 작동 방식은 업데이트 방법에 대한 고민이 필요없지만 동적인 UI 를 보여주려면 속도가 굉장히 느릴 것임. 

리액트에서는 **Virtual DOM** 을 사용해 이를 가능하게 했음. 

**Virtual DOM** 이란 가상의 DOM 임. 브라우저에 실제 존재하는 DOM 이 아니라 메모리에 가상으로 존재하는 DOM 으로, JavaScript 객체여서 브라우저에서 DOM 을 보여주는 것보다 속도가 훨씬 빠름. 

리액트는 업데이트가 필요한 곳의 UI 을 Virtual DOM 을 통해 렌더링함. 그리고 리액트의 비교 알고리즘을 통해 실제 브라우저에 보여지고 있는 DOM 과 비교 후, 차이점을 감지해 이를 실제 DOM 에 패치해줌. 결국, 효율적인 작동 방식과 속도 모두를 챙길 수 있게 됨.

### 03. 리액트 컴포넌트

리액트 컴포넌트를 만들 때, 

~~~javascript
import React from 'react'
~~~

를 통해 리액트를 불러와야하고

~~~javascript
export default Hello;
~~~

를 통해 컴포넌트를 내보내 다른 컴포넌트에서 불러와 사용할 수 있음.

다음과 같이 Hello 라는 컴포넌트를 만들고

~~~javascript
import React from 'react';

function Hello() {
  return <div>안녕하세요</div>
}

export default Hello;
~~~

App.js 에서 불러와 사용하면

~~~javascript
import React from 'react';
import Hello from './Hello'; //Hello 컴포넌트를 불러옴

function App() {
  return (
    <div>
      <Hello />
    </div>
  );
}

export default App;
~~~

컴포넌트를 일종의 UI 조각으로, 다음과 같이 쉽게 재사용할 수 있음

~~~javascript
import React from 'react';
import Hello from './Hello';


function App() {
  return (
    <div>
      <Hello />
      <Hello />
      <Hello />
    </div>
  );
}

export default App;
~~~

index.js 를 보면

~~~javascript
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

ReactDOM.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
  document.getElementById('root')
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();
~~~

여기서 ReactDOM.render 의 역할은 브라우저에 실제 DOM 내부에 리액트 컴포넌트를 렌더링하는 것임. 
**id** 가 **root** 인 DOM 을 선택하고 있는데, 이 DOM 은 public/index.html 에 위치함.

~~~html
<body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div> 
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
~~~

리액트 컴포넌트가 렌더링된 결과물이 위 div 내부에 렌더링됨.

### 04. JSX

**JSX** 는 리액트에서 생김새를 정의할 때 사용하는 문법임. 
html 같이 생겼지만 실제로는 javascript 임.

~~~javascript
return <div>안녕하세요</div>;
~~~

리액트 컴포넌트 파일에서 XML 형태로 코드를 작성하면 babel(js<->JSX 컴파일러) 이 JSX 를 javascript 로 변환해줌.

JSX 가 javascript 로 제대로 변환이 되려면 지켜야할 몇 가지 규칙이 있음.

#### 꼭 닫혀야하는 태그

태그는 꼭 닫혀야 한다. 

다음과 같이 닫히지 않은 태그가 있는 코드는 오류가 발생하게 됨.

~~~javascript
import React from 'react';
import Hello from './Hello';

function App() {
  return (
    <div>
      <Hello />
      <Hello />
      <Hello />
      <div>
    </div>
  );
}

export default App;
~~~

태그와 태그 사이에 내용이 없을 때, **Self Closing 태그** 를 사용함. 위 코드에서 Hello 컴포넌트를 사용할 때 이미 Self Closing 태그를 사용했는데, 
<Hello /> 와 같이 사용하며 열리고 바로 닫히는 태그를 의미함.

#### 꼭 감싸야하는 태그

두 개 이상의 태그는 무조건 하나의 태그로 감싸야함. 

~~~javascript
import React from 'react';
import Hello from './Hello';

function App() {
  return (
    <Hello />
    <div>안녕히계세요.</div>
  );
}

export default App;
~~~

Hello 와 div 태그를 하나의 태그로 감싸지 않아 오류가 발생함. 

다음과 같이 div 태그로 감싸도 되지만 주로 리액트의 **Fragment**를 사용함. 

~~~javascript
function App() {
  return (
    <div>
      <Hello />
      <div>안녕히계세요</div>
    </div>
  );
}
~~~

사용법은 다음 코드와 같이 <>두 개 이상의 태그</> 로 사용함. 브라우저 상에서는 별도의 요소로 나타나지 않음.

~~~javascript
function App() {
  return (
    <>
      <Hello />
      <div>안녕히계세요</div>
    </>
  );
}
~~~

#### JSX 안에서 자바스크립트 값 사용하기

JSX 안에서 자바스크립트 변수를 보여줘야할 때는 **{}** 를 사용함.

~~~javascript
import React from 'react';
import Hello from './Hello';

function App() {
  const name = 'react';
  return (
    <>
      <Hello />
      <div>{name}</div>
    </>
  );
}

export default App;
~~~

#### style 과 className

인라인 스타일 -> 객체 형태로 작성
**background-color** 처럼 하이푼으로 구분되어 있는 이름은 **backgroundColor** 처럼 [camelCase](https://ko.wikipedia.org/wiki/%EB%82%99%ED%83%80_%EB%8C%80%EB%AC%B8%EC%9E%90) 형태로 네이밍 해야한다. 

~~~javascript
import React from 'react';
import Hello from './Hello';

function App() {
  const name = 'react';
  const style = {
    backgroundColor: 'black',
    color: 'aqua',
    fontSize: 24, // 기본 단위 px
    padding: '1rem' // 다른 단위 사용 시 문자열로 설정
  }

  return (
    <>
      <Hello />
      <div style={style}>{name}</div>
    </>
  );
}

export default App;
~~~